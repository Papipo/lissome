defmodule Mix.Tasks.Compile.GleamJs do
  use Mix.Task

  @shortdoc "Compile Gleam source files to JavaScript and then bundle them using esbuild binary"
  @shell Mix.shell()

  @moduledoc """
  #{@shortdoc}

  Built files are placed in the `priv/static/gleam` folder.

  ## Examples:

      # Compile Gleam to Javascript in a Mix project
      # and bundle with esbuild in minified mode
      mix compile.gleam_js --minify

  Gleam compilation will not occur where no `.gleam` files are located.

  Include this task in your project's `mix.exs` with, e.g.:

      def project do
        [
          compilers: [:gleam_js] ++ Mix.compilers(),
        ]
      end

  Although this task could be used standalone, it's more likely to be used with the Gleam to Erlang compiler from `mix_gleam`.

  Credit goes to the [mix_gleam](https://github.com/gleam-lang/mix_gleam) project, on which this compiler has been modeled.
  """

  @switches [
    minify: :boolean
  ]

  @impl true
  def run(args) do
    MixGleam.IO.debug_info("Javascript compilation start")

    Mix.Project.get!()

    case OptionParser.parse(args, switches: @switches) do
      {options, _, _} ->
        config = Keyword.merge(options, Mix.Project.config())

        app =
          try do
            Keyword.get_lazy(config, :app, fn -> elem(config[:lock], 1) end)
          rescue
            _ -> raise MixGleam.Error, message: "Unable to find app name"
          end

        build_dir = Path.join([Mix.Project.build_path(), "lib", "#{app}"])

        gleam? =
          File.exists?("src") and Enum.any?(File.ls!("src"), &String.ends_with?(&1, ".gleam"))

        if gleam? do
          compiled_files = compile(app, build_dir)

          bundle(compiled_files, config, app, build_dir)
        end
    end

    MixGleam.IO.debug_info("Javascript compilation end")
  end

  defp compile(app, build_dir) do
    # A minimal `gleam.toml` config with a project name is required by
    # `gleam build`.
    #
    # We reuse the generated by a previous erlang compilation if any,
    # otherwise we create one here.
    cond do
      File.regular?(Path.join(build_dir, "gleam.toml")) ||
          File.regular?("gleam.toml") ->
        :ok

      true ->
        build_dir
        |> Path.join("gleam.toml")
        |> File.write!(~s(name = "#{app}"))
    end

    cmd =
      "gleam build --target javascript"

    @shell.info(~s(Compiling #{app} gleam frontend to javascript))
    MixGleam.IO.debug_info("Compiler Command", cmd)
    compiled? = @shell.cmd(cmd, cd: build_dir) === 0

    if compiled? do
      build_dir
      |> Path.join("build/dev/javascript/#{app}")
      |> File.ls!()
      |> Enum.filter(&(String.ends_with?(&1, ".mjs") and &1 != "gleam.mjs"))
      |> Enum.map(&Path.join([build_dir, "build/dev/javascript/#{app}", &1]))
    else
      raise MixGleam.Error, message: "JS Compilation failed"
    end
  end

  defp bundle(compiled_files, config, app, build_dir) do
    priv = :code.priv_dir(app)
    out = "#{priv}/static/gleam"

    File.mkdir_p!(out)

    esbuild = Esbuild.bin_path()

    args =
      compiled_files
      |> prepend_minify(config[:minify])
      |> Enum.concat(~w(--bundle --format=esm --outdir=#{out}))

    bundled? =
      esbuild
      |> System.cmd(args)
      |> elem(1) === 0

    if bundled? do
      Enum.each(compiled_files, fn file ->
        base_name = Path.basename(file, ".mjs")
        entry = build_entry(base_name)
        File.write!(Path.join(out, "#{base_name}.entry.mjs"), entry)
      end)

      clean_js_build(build_dir)
      :ok
    else
      raise MixGleam.Error,
        message:
          "JS Bundling failed. Check if you have esbuild binary in your Elixir's build directory."
    end
  end

  defp build_entry(base_name) do
    "import { main } from './#{base_name}.js'; main?.();"
  end

  defp prepend_minify(args, minify) do
    if minify,
      do: ["--minify" | args],
      else: args
  end

  defp clean_js_build(build_dir) do
    File.rm_rf!(Path.join(build_dir, "build/dev/javascript"))
  end
end
